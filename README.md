Литература
 https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html


# SOLID принципы ООП
> ## Single Responsibility | Принцип единственной ответственности
>> ### Класс Юзер не отвечает за платёжки
> ## Open/closed | Принцип открытости/закрытости
>> ### Открыты к расширению, закрыты к изменению
>> ### Вместо изменения родителя можно добавить дочку с новым функционалом
```php
interface ReportInterface {
    public function generate(): string;
}

class PDFReport implements ReportInterface {
    public function generate(): string {
        return "Отчет в формате PDF";
    }
}

class CSVReport implements ReportInterface {
    public function generate(): string {
        return "Отчет в формате CSV";
    }
}

class ReportPrinter {
    private ReportInterface $report;

    public function __construct(ReportInterface $report) {
        $this->report = $report;
    }

    public function print(): void {
        echo $this->report->generate();
    }
}
```
> ## Liskov Substitution | Барбары Лисков
>> ### Объекты одного типа должны быть заменяемы без изменения поведения
>> ### Если у нас есть клас юзер, то любой класс наследующий юзера должен иметь условный метод getName
```php
class Bird {
    public function fly(): string {
        return "Птица летит";
    }
}

class Sparrow extends Bird {
    public function fly(): string {
        return "Воробей летит";
    }
}

class Ostrich extends Bird {
    public function fly(): string {
        throw new Exception("Страусы не летают");
    }
}
```
> ## Interface Segregation | Принцип разделения интерфейса
>> ### Лучше иметь несколько интерфейсов чем один большой
>> ### Интерфейсы лучше разбивать на несколько штук если функционал используется частично
> ## Dependency Inversion | Принцип инверсии зависимостей
>> ### Классы должны зависеть от абстракций (интерфейсов), а не от реализаций
>> ### Если класс напрямую использует класс базы данных, лучше использовать интерфейс DatabaseInterface, чтобы можно было легко подменить, например, MySQL на PostgreSQL, не меняя логику программы

# ООП
> ### Наследование один класс наследует свойства и методы другого класса
> ### Инкапсуляция обеспечивает целостность объекта и позволяет пользоваться им не вдаваясь в детали реализации
> ### Полиморфизм позволяет объектам одного типа использовать методы родителя по разному

# CORS
> ## Веб стандарт для управления доступом из разных источников
>> ### Access-Control-Allow-Origin:  Определяет, разрешен ли доступ к ресурсу с указанных источников
>> ### Access-Control-Allow-Methods: Определяет, какие методы HTTP разрешены при запросе к ресурсу
>> ### Access-Control-Allow-Headers: Определяет список разрешенных заголовков при запросе к ресурсу

# Позднее статическое связывание
> ### Механизм, который позволяет использовать классам полиморфизм, вызов статических методов и свойств дочернего класса из родительского
```php
class A {
    public static function whoAmI() {
        var_dump(__CLASS__);
    }
    
    public static function callWhoAmI() {
        self::whoAmI();
    }
}

class B extends A {
    public static function whoAmI() {
        var_dump(__CLASS__);
    }
}

A::whoAmI(); string(1) "A"
A::test(); string(1) "A"
B::whoAmI(); string(1) "B"
B::callWhoAmI(); string(1) "A"
```
# Магия
> ## __construct()
>> ### Конструктор класса, вызывается при создании объекта
> ## __destruct(): 
>> ### Деструктор класса, вызывается при уничтожении объекта
> ## __get($name): 
>> ### Вызывается, когда происходит попытка доступа к несуществующему или защищенному свойству объекта
> ## __set($name, $value): 
>> ### Вызывается, когда происходит попытка установки значения несуществующему или защищенному свойству
> ## __call($name, $arguments): 
>> ### Вызывается, когда происходит попытка вызова несуществующего или защищенного метода объекта
> ## __toString(): 
>> ### Вызывается при попытке преобразования объекта в строку
> ## __invoke(): 
>> ### Вызывается при попытке вызвать объект как функцию
> ## __clone(): 
>> ### Вызывается при клонировании объекта
> ## __sleep() и __wakeup(): 
>> ### Используются для управления сериализацией объектов
```php
class Magic {
    private $data = [];

    public function __set($name, $value) {
        $this->data[$name] = $value;
    }

    public function __get($name) {
        return $this->data[$name] ?? null;
    }

    public function __call($name, $arguments) {
        return "Method $name was called with arguments: " . implode(', ', $arguments);
    }

    public function __toString() {
        return "This is a Magic class.";
    }
}

// Использование магических методов
$magic = new Magic();
$magic->name = "John"; // Вызов __set()
echo $magic->name; // Вызов __get() выводит: John
echo $magic->nonExistingMethod('arg1', 'arg2'); // Вызов __call()
echo $magic; // Вызов __toString() выводит: This is a Magic class.
```

# Магию объединяет
> ### То, что они предоставляют возможность переопределения стандартного поведения объектов в PHP
> ### Эти методы зарезирвированы в php и все начинаются с двойного подчеркивания (__)

# Чем отличается класс от объекта
> ### Класс - шаблон для создания объектов
> ### Объект - конкретный экзепляр класса (элемент данных)

# Согласованность системы
> ### Данные или состояние системы находятся в соответствии с определенными правилами, ограничениями или ожиданиями в каждый момент времени и в любом состоянии системы

# Разница feature & unit тестирования
> ### Unit - проверяет методы или классы (какой-то маленький кусок кода)
> ### Feature - проверяет какую-то фичу целиком и полностью, какие-то сервис / интеграции и т.д.

# Варианты использования middleware
> ### Аутентификация и авторизация
> ### Логирование
> ### Кэширование
> ### Валидация данных
> ### Локализация

# Оркестрация
> ### Координация работы между различными частями системы
> ### Kubernetes / Docker / Apache / etc

# PSR4
> ### Стандарт, определяющий структуру именования классов для автозагрузчика классов в php
> ### Связывает пространство имен класса с файлом на диске
> ### Каждый сегмент неймспейса соответствует поддиректории, а имя класса должно совпадать с именем файла
```php
// Файл: src/Services/EmailService.php
namespace App\Services;

class EmailService {
    // ...
}
```
# Final class
> ### Защита от изменений
> ### Улучшение производительности (нет необходимости проверять переопределение при вызове метода)

# Генераторы
> ### Тип функции, создающий итераторы с помощью синтаксиса с использованием yield
> ### Ленивая загрузка значений, генерирует значения по мере необходимости не загружая оперативку

# Типы данных
> ### integer, float, string, bool, array, object, resource, null

# Формат данных
> ### json, xml, csv, protobuf, html, yaml

# Класс это тип данных?
> ### Да, в контексте ООП
> ### Мы сами определяем новый тип/структуру данных которая описывание состояние и поведение объекта
> ### Класс является шаблоном описывающим тип данных

# ORM (Object Relational Mapping)
> ### Это программный подход, который позволяет разработчикам работать с базами данных с использованием объектно-ориентированного подхода, то есть представлять данные в базе данных в виде объектов в коде программы.

# ActiveRecord от дата мапера чем отличается
> ### Active record паттерн проектирования в котором каждый объект бд связан с экземпляром класса (laravel eloquent)
> ### Data mapper подход к реализации ORM который отделяет объекты приложения от структуры бд

# Что такое протокол в протоколе передачи данных
> ### Это набор правил и соглашений, которые определяют, каким образом устройства в сети будут обмениваться информацией

# Уровни сетевой модели OSI
> ### Физический уровень 
>> ### Самый нижний уровень, отвечает за передачу физических сигналов (электрических, оптических или радиоволн) по проводам, волокнам или радиоканалам
> ### Канальный уровень
>> ### Отвечает за передачу кадров данных между узлами на одном уровне сети
> ### Сетевой уровень
>> ### Определяет, как пакеты данных маршрутизируются между различными сетями (например, с использованием IP)
> ### Транспортный уровень
>> ### Этот уровень гарантирует, что данные передаются надёжно и без ошибок. Здесь данные разбиваются на сегменты, и система следит за тем, чтобы все сегменты пришли целыми и в правильном порядке
> ### Сеансовый уровень
>> ### Этот уровень управляет сеансами связи, управление подключением в FTP или SSH
> ### Уровень представления
>> ### На этом уровне данные превращаются в формат, который может быть понятен принимающей стороне. Здесь выполняется шифрование, сжатие и преобразование форматов данных
> ### Прикладной уровень 
>> ### Это уровень, с которым взаимодействует пользователь напрямую. Все программы, которые используют сеть, работают на этом уровне, браузеры/почтовые клиенты

# lazyCollection
> ### Данные загружаются по мере необходимости
> ### Память используется гораздо эффективнее
> ### Использует генератор через ключевое слово yield

# Два трейта с одинаковыми методами, как использовать
```php
trait A {
    public function doSomething() {
        echo "From A\n";
    }
}

trait B {
    public function doSomething() {
        echo "From B\n";
    }
}

class MyClass {
    use A, B {
        A::doSomething insteadof B;  // Использовать метод из трейта A
        B::doSomething as doSomethingFromB;  // Переименовать метод из B
    }
}

$obj = new MyClass();
$obj->doSomething();        // From A
$obj->doSomethingFromB();   // From B
```

# JRPC 
> ### Протокол для удалённого вызова процедур
> ### Простота | Однонаправленность | Поддержка асинхронности | Легковестность
> ### Состоит из версии протокола, метода, параметров и id запроса
> ### Запросы летят преимущественно на 1 url по типу http://localhost/grpc

# Protobuf (Protocol Buffers)
> ### Механизм сериализации данных, разработанный Google, который используется для структурирования и обмена данными между системами
> ### Протокол позволяет описывать структуры данных в формате .proto который компилируется в код на разных языках (php/go/python). Это позволяет сериализовать и десериализовать данные для передачи между различными сервисами
> ### Протокол бинарный, а как следствие более компактный и быстрый, нежели json || xml

# JRPC & Protobuf
> ### Протоколы могуть использоваться вместе для повышения производительности JRPC, заменяя json на бинарный формат protobuf
> ### Главным преимуществом при таком взаимодействие является высокая производительность и компактность сообщений

# Docker Swarm
> ### Встроенная оркестрация контейнеров в Docker, которая позволяет управлять несколькими контейнерами в распределённой среде
> ### В отличии от простого запуска контейнеров на одном хосте, swarm позволяет объединить несколько нод в кластер и эффективно управлять контейнерами на нодах
> ### Swarm имеент встроенный балансировщик нагрузки, позволяющий распределять запросы к сервису между репликами через виртуальный IP
> ## Архитектура
> ### Manager ноды - Управляют состоянием кластера, принимают решения о распределении задач, отслеживают состояние всех нод. Может иметь несколько менеджеров для обеспечения отказоустойчивости, но одна из них всегда будет главной (lead manager)
> ### Worker ноды - Рабочие ноды, выполняют контейнеры, называемые 'таски'. Они получают инструкцию от менеджеров и сообщают им о своём состоянии
> ### Services - Определение контейнера, его конфигурация и количество реплик, которое нужно запустить. Это единица масштабирования в swarm
> ### Tasks - Каждая реплика сервиса представляет собой таску. Таска - экземпляр контейнера, который запускается на одной из нод
> ## Прочее
> ### Overlay сеть - используется для связи между контейнерами, запущенными на разных нодах
> ### Swarm автоматически восстанавливает контейнеры при сбое. Если один из серверов выходит из строя, переназначает таски на другие рабочие ноды
> ### Если менеджер нода выходи из строя - один из других менеджеров становится новым лидером
> ### Portainer устанавливается как docker service в кластере swarm
> ## Полезные команды
> ### docker service ls # список сервисов
> ### docker node ls # список нод в кластере
> ### docker service ps <service-name> # список всех задач в сервисе

# Шины данных 
> ### Архитектурная концепция которая организует обмен данными между различными компонентами системы
> ### Помогает передавать события / запросы / сообщения между сервисами

# Кластеризация
> ### Разделение нагрузки между несколькими серверами или процессами для увеличения производительности и масштабируемости
> ### Простыми словами - объединение серверов в кластер, где они совместно обрабатывают запросы или поддерживают БД
> ### В условном laravel можно настроить кластеризацию с помощью очередей и балансировщика нагрузки (nginx)
> ### В контексте баз данных кластеризация предполагает создание реплик или шардирования бдшки

# Селективность
> ### Эффективность индексирования и выполнения запросов к базе данных
> ### Селективность индекса показывает насколько он способен сокращать количество строк в таблице при выполнении запроса
> ### Чем выше селективность тем лучше индекс отфильтровывает строки, тем быстрее отрабатывают запросы
> ### Селективность = Число уникальных значений / общее количество строк
> ### Высокая - если индекс имеет много уникальных значений (например по unique ID)
> ### Низкая - если используются по столбцу в котором много одинаковых значений (булевы / статусные)

# Race Condition (Состояние гонки)
> ### Проблема в многопоточных и параллельных системах, когда несколько процессов или потоков пытаются получить доступ и изменить общие данные
> ### В результате конечное состояние может быть неопределённым или неверным т.к. зависит от порядка выполнения
> ## Как бороться?
>> ### Пессимистическая блокировка (Транзакции и блокировки баз данных)
>> ### Оптимистическая блокировка (перед сохранением проверяется не изменились ли данные с момента чтения)
>> ### Атомарные операции (Product::where('id', $productId)->where('stock', '>', 0)->decrement('stock'))
>> ### Последовательные очереди

# Виртуализация и контейнерезация
> ### Два ключевых подхода к изоляции и управлению вычислительными ресурсами. Оба используются для создания изолированных сред, но имеют разные архитектурные принципы и преимущества
> # Виртуализация
>> ### Технология которая позволяет создать несколько виртуальных машин на одном физическом сервере
>> ### Каждая виртуальная машина работает как отдельный компьютер с собственным операционным окружением, а также со своим набором ресурсов (проц, память, дисковое пространство)
>> ## Как работает
>> ### На физическом сервере устанавливается гипервизор (VMware / Hyper-V / KVM), которое управляет машинами
>> ### Каждая машина получает собственную копию ОС (Linux / Windows) а также доступ к ресурсам
>> ### Гипервизор распределяет ресурсы сервера между машинами
>> ## Преимущества
>> ### Полная изоляция каждой машины
>> ### Возможность работать с различными ОС на одном сервере
>> ### Безопасность и изоляция ресурсов
>> ## Недостатки
>> ### Большие расходы на каждую из машин из-за запуска отдельных ОС
>> ### Медленное развертывание и управление по сравнению с контейнерами
> # Контейнерезация
>> ### Технология, которая изолирует приложение вместе со всеми зависимостями в лёгкие контейнеры, которые работаю на общей ОС
>> ### Контейнеры не требуют запуска полноценной ОС внутри каждой изолированной среды
>> ## Как работает
>> ### Контейнеры работают поверх ядра ОС хост-машины
>> ### В отличии от VM контейнеры используют общие ресурсы хостовой ОС, но обеспечивают изоляцию на уровне процессов и файловой системы
>> ### Могут быть запущены и управляемы с помощью Docker & Kubernetes
>> ## Преимущества
>> ### Лёгкость и быстрота запуска
>> ### Низкие расходы т.к. нет необходимости запускать полные ОС
>> ### Простота в управлении зависимостями и окружением
>> ### Лёгкая миграция контейнеров между серверами
>> ### Широко используется дли микросервисной архитектуры
>> ## Недостатки
>> ### Меньший уровень изоляции & безопасности по сравнению с VM (т.к. общее ядро ОС)

# Kafka
> ### Распреденённая платформа для потоковой передачи данных с высокой происзводительностью и масштабируемостью
> ### Вкратце - система обмена сообщениями между приложениями, где требуется высокая надёжность и пропускная способность
> ### Состоит из трёх ключевых компонентов - Producer / Consumer / Broker

# Stub & Mock
> ## Stub
>> ### Объект заглушка который предоставляет заранее определённые значения без вызова методов
>> ### Простыми словами - возвращает предсказуемый результат
>> ### ```$user = $this->createMock(User::class);```
>> ### ```$user->method('save')->willReturn(true);```
> 
> ## Mock
>> ### Более сложная заглушка которая не только возвращает предопределённые значения но также следит за тем, как объект используется в коде
>> ### Можно проверить взаимодействие между объектами, как часто был вызван метод, с какими параметрами и сколько раз
>> ### Тестируется не только результат но и поведение
>> ### ```$user = Mockery::mock(User::class);```
>> ### ```$user->shouldReceive('save')->once()->andReturn(true);```
>> ### ``` Mockery::close();```

# Области видимости
> ### public - доступны отовсюду
> ### private - доступны только там где объявлены
> ### protected - доступны там где объявлены и в дочерних классах

# Rest & Spread операторы
> ### Rest (... в параметрах функции)
> ### Позволяет передать производное количество аргументов в функцию или метод в виде массива
> ### Используется когда количество аргументов неизвестно заранее или нужно передать большое кол-во параметров
```php
function sum(...$numbers)
{
    return array_sum($numbers);
}

echo sum(1, 2, 3, 4); // 10
```
> ### Spread (... для передачи массива в функцию)
> ### Позволяет передать элементы массива в функцию как отдельные аргументы
> ### Полезно когда есть массив, а функция ожидает отдельные аргументы
```php
function sum($a, $b, $c)
{
    return $a + $b + $c;
}

$numbers = [1, 2, 3];
echo sum(...$numbers); // 6
```

# Что происходит после ввода google.com в поисковике
> 1. ### Браузер отправляет запрос к DNS серверу (Domain Name System), чтобы определить IP-адрес сайта, соответствующий введенному доменному имени.
> 2. ### После получения IP-адреса браузер устанавливает TCP-соединение с сервером, на котором размещен веб-сайт.
> 3. ### Браузер отправляет запрос к серверу с заголовками
> 4. ### Сервер обрабатывает запрос и формирует ответ
> 5. ### Ответ передается обратно браузеру через TCP соединение
> 6. ### Браузер получает ответ
> 7. ### TCP соединение закрывается

# pg_stat_statements
> ### Расширение для pgsql которое отслеживает выполнение sql запросов и собирает по ним статистику
> ### Помогает идентифицировать медленные запросы и их частоту выполнения
> ## Установка
> ### CREATE EXTENSION pg_stat_statements;
> ## После установки
> ### SELECT * FROM pg_stat_statements;
> ## Полезные поля
> ### userid: идентификатор пользователя, который выполнил запрос
> ### dbid: идентификатор базы данных
> ### query: текст выполненного запроса
> ### calls: количество вызовов запроса
> ### total_time: общее время выполнения запроса (в миллисекундах)
> ### min_time, max_time, mean_time: минимальное, максимальное и среднее время выполнения запроса
> ### rows: количество строк, возвращенных запросом

# HasManyDeep
> ### Инструмент с большим функционалом взаимодействия с релейшенами
> ### Есть возможность прокинуть ide_helper
> ### Есть возможность использовать alias'ы если есть отношение на одну и ту же таблицу
> ### Есть возможность тянуть инфу из сводных таблиц запроса
> ### Есть возможность использовать композитный ключ 
> ### Есть возможность указывать свои кастомные foreign keys в hasManyDeep
> ### Нужно не забывать использовать трейты по типу HasRelationships || HasTableAlias

# Foreign Data Wrapper
> ### Фича pgsql позволяющая обращаться к внешним субд да и вообще к чему угодно (mysql / redis / clickhouse etc)
> ### Обеспечивают доступ к разным СУБД через одну точку доступа

# Redis
> ## Строки
> ### Текст / числа / json / бинарники
> ### SET key value: устанавливает значение по ключу
> ### GET key: получает значение по ключу
> ### INCR key: увеличивает числовое значение на 1
> ### DECR key: уменьшает числовое значение на 1
> ## Хэши
> ### Набор пар ключ => значение. Можно сохранить юзера с его атрибутами
> ### HSET key field value: устанавливает поле в хеше.
> ### HGET key field: получает значение по полю в хеше.
> ### HGETALL key: получает все поля и значения из хеша.
> ## Списки
> ### Это упорядоченные коллекции строк, которые позволяют добавлять элементы как в начало, так и в конец списка. 
> ### Очереди / задачи с приоритетом / временные последовательности событий
> ### LPUSH key value: добавляет элемент в начало списка.
> ### RPUSH key value: добавляет элемент в конец списка.
> ### LPOP key: удаляет и возвращает первый элемент списка.
> ### LRANGE key start stop: получает элементы из диапазона списка.
> ## Множества
> ### Это неупорядоченные коллекции уникальных строк. Они поддерживают операции над множествами, такие как объединение и пересечение
> ### Уникальные элементы, системы тегов, группы пользователей
> ### SADD key member: добавляет элемент в множество.
> ### SREM key member: удаляет элемент из множества.
> ### SMEMBERS key: получает все элементы множества.
> ### SUNION key1 key2: объединяет два множества.
> ## Сортированные Множества
> ### Сортированные множества похожи на обычные множества, но каждый элемент имеет связанный с ним "балл", который определяет его порядок
> ### Рейтинг, очереди с приоритетом, временные метки
> ### ZADD key score member: добавляет элемент с указанным баллом.
> ### ZRANGE key start stop: получает элементы в заданном диапазоне по индексу.
> ### ZREM key member: удаляет элемент из сортированного множества.

# Redis CLI
> ### Встроенный клиент командной строки для взаимодействия с redis
> ### INFO Получение информации о сервере Redis (Память, статистика операций, загрузка процессора)
> ### MONITOR Запуск мониторинга всех команд, выполняемых на сервере в реальном времени
> ### CLIENT LIST Получение списка подключенных клиентов
> ### SLOWLOG Просмотр медленных запросов

# Redis Insight
> ### Графический интерфейс для мониторинга и управления Redis

# Метапрограммирование
> ### Reflection API
> ### Reflection API позволяет получать информацию о классах, методах, свойствах и параметрах в PHP во время выполнения. Это полезно для анализа структуры классов и создания динамических объектов
> ### ReflectionClass: предоставляет информацию о классах.
> ### ReflectionMethod: предоставляет информацию о методах класса.
> ### ReflectionProperty: предоставляет информацию о свойствах класса.
> ### ReflectionParameter: предоставляет информацию о параметрах методов.

# Хэш индекс (O (1))
> ### Хэш таблица где ключи - значения столбца, эффективны для точного поиска без сложных запросов
> ### Создаётся в отдельной таблице отдельная запись - генерируется ключ и присваивается значение
> ### Нельзя искать в диапазоне, используется только строгое сравнение
> ### Занимают много памяти

# (BTree) Balanced Tree индекс (O (log n))
> ### Сбалансированное дерево - структура данных, широко используемая для ускорения поиска, вставки и удаления данных в реляционных бд
> ### Дерево строится диапазонами и мы смотрим по искомому числовому индексу, начиная сверху
> ### Сравнивается искомый id со значениями в диапазоне больше или меньше и от этого происходит выбор ветки
> ### Перезаписывается диапазон при обновлении удалении

# Составной индекс (O (log n))
> ### Индекс, который включает несколько колонок таблицы
> ### Он используется для оптимизации запросов, которые фильтруют или сортируют данные по нескольким полям одновременно

# Покрывающий индекс (O (log n))
> ### Индекс, который содержит все данные, необходимые для выполнения конкретного запроса
> ### Устраняет необходимость обращения к основной таблице, что снижает количество операций ввода-вывода
> ### Использование индекса уменьшает число чтений с диска, так как обычно индексы хранятся более компактно, чем вся таблица

# Вертикальное масштабирование
> ### Процесс увеличения мощности одного сервера за счёт улучшения его аппаратных характеристик (CPU / RAM / SSD)

# Горизонтальное масштабирование
> ### Процесс добавления новых серверов в инфраструктуру для распределения нагрузки и увеличения вычислительных мощностей системы 
> ### Вместо улучшения одного сервера, добавляете несколько серверов (нод), которые работают совместно

# Репликация
> ### Процесс копирования и синхронизации данных с одного сервера (мастера) на несколько других серверов (реплик)

# Шардирование
> ### Процесс разделения данных на несколько независимых частей (шардов), каждая из которых хранится на отдельном сервере или ноде
> ### Если у есть таблица пользователей с миллионами записей, вместо хранения всей таблицы на одном сервере, можно разделить её на несколько шардов по какому-либо критерию, например по региону или диапазону идентификаторов
> ### В результате: На одном сервере будут храниться пользователи с ID от 1 до 1,000,000. На другом сервере — пользователи с ID от 1,000,001 до 2,000,000 и так далее.

# Партицирование
> ### Процесс разделения таблицы базы данных на более мелкие, логически независимые части, называемые партициями
>> ### Диапазонное
>> ### Данные разделяются на партиции на основе диапазона значений столбца
>> ### ```PARTITION BY RANGE (transaction_date);```
>
>> ### Хэш
>> ### Данные распределяются между партициями с использованием хэш-функции для равномерного распределения данных
>> ### ```PARTITION BY HASH (customer_id);```
>
>> ### Список
>> ### Данные разделяются на основе фиксированных значений из заранее определенного списка. Например, распределение заказов по странам
>> ### ```PARTITION BY LIST (region) (```
>> ### ```PARTITION p_north VALUES IN ('North America', 'Europe'),```
>> ### ```PARTITION p_asia VALUES IN ('Asia', 'Australia'),```
>> ### ```PARTITION p_africa VALUES IN ('Africa')```
>> ### ```);```
>
>> ### Композитное
>> ### Комбинирует несколько методов партиционирования, например, сначала по диапазону, а затем по хэшу
>> ### 
>> ### ```PARTITION BY LIST (region) (```
>> ### ```PARTITION p_north VALUES IN ('North America', 'Europe')```
>> ### ```PARTITION BY HASH(customer_id) PARTITIONS 4,```
>> ### ```PARTITION p_asia VALUES IN ('Asia', 'Australia')```
>> ### ```PARTITION BY HASH(customer_id) PARTITIONS 4,```
>> ### ```PARTITION p_africa VALUES IN ('Africa')```
>> ### ```PARTITION BY HASH(customer_id) PARTITIONS 4```
>> ### ```);```

# Консистентность
> ### Свойство, которое гарантирует, что все узлы в системе видят одинаковые данные в любой момент времени
>> ### Строгая
>> ### Обеспечивает, что после выполнения транзакции все участники системы немедленно видят актуальные данные 
>> ### Любое чтение данных всегда возвращает самое свежее их состояние
>> ### К примеру master-slave
> 
>> ### Конечная
>> ### Обещает, что данные в конечном итоге станут согласованными на всех узлах, но допускает задержку во времени
>> ### К примеру асинхронная репликация
> 
>> ### Чтение-запись
>> ### Гарантирует, что после успешной записи все последующие чтения вернут обновлённые данные
>> ### Это баланс между строгой и конечной консистентностью

# Согласованность 
> ### Свойство системы которое гарантирует целостность данных при выполнении операций
> ### После каждой операции бд всегда остаётся в согласованном состоянии, т.е. данные удовлетворяют всем правилам, ограничениям и условиям

# ACID
> ### Атомарность 
>> ### Транзакция либо выполняется полностью, либо не выполняется вовсе
> ### Согласованность 
>> ### После выполнения транзакции база данных должна перейти из одного согласованного состояния в другое
>> ### Это означает, что все ограничения, такие как уникальные ключи, внешние ключи, проверочные условия, должны быть соблюдены
> ### Изоляция 
>> ### Транзакции не должны мешать друг другу
>> ### Результат транзакции не должен быть виден до её завершения
> ### Долговечность 
>> ###  После успешного выполнения транзакции её результаты должны быть зафиксированы в базе данных и сохранены, даже если произойдёт сбой системы

# Отличие where & having
> ### Where - конкретный поиск до выполнения groupBy
> ### Having - применяется после groupBy или агрегатных функций

# Уровни изоляции бд
> ### Read Uncommitted (Чтение Незафиксированных Данных)
>> ### Транзакция может прочитать данные, которые не были зафиксированы другой транзакцией и могут быть отменены
>
> ### Read Committed (Чтение Зафиксированных Данных)
>> ### На этом уровне транзакция видит только данные, которые были зафиксированы другими транзакциями
> 
> ### Repeatable Read (Повторяемое Чтение)
>> ### Гарантирует, что если транзакция дважды прочитает одно и то же значение, оно не изменится в течение транзакции
> 
> ### Serializable (Сериализуемость)
>> ### Транзакции исполняются так, как будто они идут последовательно, одна за другой, даже если на самом деле они выполняются параллельно

# Нормализация бд
> ### Процесс структурирования базы данных с целью минимизации избыточности данных и повышения их целостности

# Уровни нормализации
> ### 1NF
>> ### Все столбцы содержат только неделимые значения
>> ### Все значения в столбцах одного типа
> ### 2NF
>> ### Она уже находится в 1NF
>> ### Все неключевые атрибуты полностью функционально зависят от первичного ключа (т.е. не зависят от части составного ключа)
> ### 3NF
>> ### Она уже находится во 2NF
>> ### Нет транзитивных зависимостей (т.е. неключевые атрибуты не зависят от других неключевых атрибутов)
> ### BCNF
>> ### Она уже находится в 3NF
>> ### Устраняет ситуации, когда нет уникального ключа для функциональной зависимости
> ### 4NF
>> ### Она уже находится в BCNF
>> ### Не содержит многозначных зависимостей, где один ключ может определять более одного значения в другом столбце
> ### 5NF
>> ### Она уже находится в 4NF
>> ### Все зависимости могут быть восстановлены с помощью соединений

# Функции
> ### CREATE OR REPLACE FUNCTION — создаёт новую функцию или заменяет существующую
> ### RETURNS — указывает тип возвращаемого значения (например, INTEGER, TEXT, BOOLEAN или TABLE)
> ### LANGUAGE plpgsql — указывает язык, на котором написана функция. В данном случае это PL/pgSQL
```postgresql
CREATE OR REPLACE FUNCTION function_name(parameter_name datatype, ...)
RETURNS return_datatype AS $$
BEGIN
    RETURN результат;
END;
$$ LANGUAGE plpgsql;
```
> ### Else if
```postgresql
CREATE OR REPLACE FUNCTION check_number_sign(x INTEGER)
RETURNS TEXT AS $$
BEGIN
    IF x > 0 THEN
        RETURN 'Положительное';
    ELSIF x < 0 THEN
        RETURN 'Отрицательное';
    ELSE
        RETURN 'Ноль';
    END IF;
END;
$$ LANGUAGE plpgsql;
```
> ### Возвращение таблицы
```postgresql
CREATE OR REPLACE FUNCTION get_users_by_age(min_age INTEGER)
RETURNS TABLE(id INTEGER, name TEXT, age INTEGER) AS $$
BEGIN
    RETURN QUERY
    SELECT id, name, age FROM users WHERE age > min_age;
END;
$$ LANGUAGE plpgsql;
```
> ### Итерации и циклы
```postgresql
CREATE OR REPLACE FUNCTION sum_to_n(n INTEGER)
RETURNS INTEGER AS $$
DECLARE
    result INTEGER := 0;
BEGIN
    FOR i IN 1..n LOOP
        result := result + i;
    END LOOP;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```
> ### Обработка ошибок
```postgresql
CREATE OR REPLACE FUNCTION divide_numbers(a NUMERIC, b NUMERIC)
 RETURNS NUMERIC AS $$
BEGIN
 RETURN a / b;
EXCEPTION
 WHEN division_by_zero THEN
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

# Тригеры
> ### Специальные объекты базы данных, которые автоматически запускаются в ответ на определённые события (вставка, обновление, удаление) в определённых таблицах или представлениях
> ## Основные компоненты
>> ## Событие
>> ### Действие которое запускает триггер (insert / update / delete)
>> ## Момент срабатывания
>> ### Before - до выполнения события (валидация данных или модификация перед вставкой)
>> ### After - после выполнения события (логирование или отправка уведомлений)
>> ### Instead of - используется для тригеров на представлениях, чтобы перехватывать операции и выполнять вместо них определённую логику
>> ## Уровень тригера
>> ### For each row - срабатывает для каждой изменяемой строки
```postgresql
CREATE OR REPLACE FUNCTION log_each_row() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, new_data, changed_at)
    VALUES (TG_TABLE_NAME, TG_OP, row_to_json(OLD), row_to_json(NEW), NOW());

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER log_changes_trigger
AFTER UPDATE ON your_table
FOR EACH ROW
EXECUTE FUNCTION log_each_row();
```
>> ### For each statement - срабатывает один раз для всего sql запроса
```postgresql
CREATE OR REPLACE FUNCTION log_each_statement() RETURNS TRIGGER AS $$
BEGIN
 INSERT INTO audit_log (table_name, operation, changed_at)
 VALUES (TG_TABLE_NAME, TG_OP, NOW());

 RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER log_changes_statement
 AFTER UPDATE ON your_table
 FOR EACH STATEMENT
EXECUTE FUNCTION log_each_statement();
```
> ## Специальные переменные
>> ## NEW - представляет новое состояние строки (вставка или обновление)
>> ## OLD - представляет старое состояние строки (удаление или обновление)
>> ## TG_OP - тип операции, вызвавшей триггер (INSERT, UPDATE, DELETE, TRUNCATE)
>> ## TG_WHEN - время срабатывания триггера (BEFORE, AFTER)
>> ## TG_TABLE_NAME - имя таблицы, в которой произошло событие
>> ## TG_RELID - id таблицы, над которой сработал триггер
>> ## TG_NAME - имя триггера
> ## Отладка
>> ## Raise notice - команда что позволяет выводить сообщения в логи или на экран клиента для отладки
>> ## ```RAISE NOTICE 'Triggered on table: %, Action: %', TG_TABLE_NAME, TG_OP;```

# Сортировки
> ### Пузырьковая сортировка (O (n2))
>> ### Алгоритм сравнивает два соседних элемента и меняет их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока массив не будет отсортирован
```php
function bubbleSort(array &$arr) {
    $n = count($arr);
    for ($i = 0; $i < $n; $i++) {
        for ($j = 0; $j < $n - $i - 1; $j++) {
            if ($arr[$j] > $arr[$j + 1]) {
                // Меняем местами
                $temp = $arr[$j];
                $arr[$j] = $arr[$j + 1];
                $arr[$j + 1] = $temp;
            }
        }
    }
}

$arr = [64, 34, 25, 12, 22, 11, 90];
bubbleSort($arr);
print_r($arr);
//Array
//(
//    [0] => 11
//    [1] => 12
//    [2] => 22
//    [3] => 25
//    [4] => 34
//    [5] => 64
//    [6] => 90
//)
```
> ### Сортировка выбором (O (n2))
>> ### Алгоритм находит минимальный элемент в несортированной части массива и меняет его с первым элементом несортированной части. Затем эта операция повторяется для оставшейся части массива
```php
function selectionSort(array &$arr) {
    $n = count($arr);
    for ($i = 0; $i < $n - 1; $i++) {
        $minIdx = $i;
        for ($j = $i + 1; $j < $n; $j++) {
            if ($arr[$j] < $arr[$minIdx]) {
                $minIdx = $j;
            }
        }
        // Меняем минимальный элемент с текущим
        $temp = $arr[$minIdx];
        $arr[$minIdx] = $arr[$i];
        $arr[$i] = $temp;
    }
}

$arr = [64, 25, 12, 22, 11];
selectionSort($arr);
print_r($arr);
//Array
//(
//    [0] => 11
//    [1] => 12
//    [2] => 22
//    [3] => 25
//    [4] => 64
//)
```
> ### Сортировка вставками (O (n2))
>> ### Алгоритм разделяет массив на сортированную и несортированную части. Каждый элемент из несортированной части вставляется на нужную позицию в сортированную часть
```php
function insertionSort(array &$arr) {
    $n = count($arr);
    for ($i = 1; $i < $n; $i++) {
        $key = $arr[$i];
        $j = $i - 1;
        // Сдвигаем элементы массива, которые больше ключа, вправо
        while ($j >= 0 && $arr[$j] > $key) {
            $arr[$j + 1] = $arr[$j];
            $j--;
        }
        $arr[$j + 1] = $key;
    }
}

$arr = [12, 11, 13, 5, 6];
insertionSort($arr);
print_r($arr);
//Array
//(
//    [0] => 5
//    [1] => 6
//    [2] => 11
//    [3] => 12
//    [4] => 13
//)
```
> ### Быстрая сортировка (O (n2))
>> ### Алгоритм выбирает опорный элемент и разделяет массив на две части: элементы, меньшие опорного, и элементы, большие или равные опорному
```php
function quickSort(array &$arr) {
    if (count($arr) < 2) {
        return $arr;
    }
    
    $pivot = $arr[0];
    $left = $right = [];
    
    for ($i = 1, $n = count($arr); $i < $n; $i++) {
        if ($arr[$i] < $pivot) {
            $left[] = $arr[$i];
        } else {
            $right[] = $arr[$i];
        }
    }
    
    return array_merge(quickSort($left), [$pivot], quickSort($right));
}

$arr = [10, 7, 8, 9, 1, 5];
$arr = quickSort($arr);
print_r($arr);
//Array
//(
//    [0] => 1
//    [1] => 5
//    [2] => 7
//    [3] => 8
//    [4] => 9
//    [5] => 10
//)
```
> ### Сортировка слиянием (O (n log n))
>> ### Массив разбивается на две половины, каждая из которых сортируется отдельно, а затем сливается
```php
function mergeSort(array $arr) {
    if (count($arr) <= 1) {
        return $arr;
    }
    
    $mid = floor(count($arr) / 2);
    $left = array_slice($arr, 0, $mid);
    $right = array_slice($arr, $mid);
    
    $left = mergeSort($left);
    $right = mergeSort($right);
    
    return merge($left, $right);
}

function merge(array $left, array $right) {
    $result = [];
    $i = $j = 0;
    
    while ($i < count($left) && $j < count($right)) {
        if ($left[$i] <= $right[$j]) {
            $result[] = $left[$i];
            $i++;
        } else {
            $result[] = $right[$j];
            $j++;
        }
    }
    
    while ($i < count($left)) {
        $result[] = $left[$i];
        $i++;
    }
    
    while ($j < count($right)) {
        $result[] = $right[$j];
        $j++;
    }
    
    return $result;
}

$arr = [12, 11, 13, 5, 6, 7];
$arr = mergeSort($arr);
print_r($arr);
//Array
//(
//    [0] => 5
//    [1] => 6
//    [2] => 7
//    [3] => 11
//    [4] => 12
//    [5] => 13
//)
```
> ### Сортировка Шелла (O (n2))
>> ### Улучшенная версия сортировки вставками. Сначала сравниваются элементы, отстоящие друг от друга на определённое расстояние (шаг). На каждом шаге расстояние уменьшается, и в конечном итоге используется сортировка вставками для близко расположенных элементов
```php
function shellSort(array &$arr) {
    $n = count($arr);
    for ($gap = intdiv($n, 2); $gap > 0; $gap = intdiv($gap, 2)) {
        for ($i = $gap; $i < $n; $i++) {
            $temp = $arr[$i];
            $j = $i;
            while ($j >= $gap && $arr[$j - $gap] > $temp) {
                $arr[$j] = $arr[$j - $gap];
                $j -= $gap;
            }
            $arr[$j] = $temp;
        }
    }
}

$arr = [12, 34, 54, 2, 3];
shellSort($arr);
print_r($arr);
//Array
//(
//    [0] => 2
//    [1] => 3
//    [2] => 12
//    [3] => 34
//    [4] => 54
//)
```
> ### Сортировка кучей (O (n log n))
>> ### Алгоритм строит бинарную кучу из массива и последовательно извлекает максимальный (или минимальный) элемент, перестраивая кучу после каждого удаления
```php
function heapify(array &$arr, int $n, int $i) {
    $largest = $i;
    $left = 2 * $i + 1;
    $right = 2 * $i + 2;
    
    if ($left < $n && $arr[$left] > $arr[$largest]) {
        $largest = $left;
    }
    
    if ($right < $n && $arr[$right] > $arr[$largest]) {
        $largest = $right;
    }
    
    if ($largest != $i) {
        $temp = $arr[$i];
        $arr[$i] = $arr[$largest];
        $arr[$largest] = $temp;
        heapify($arr, $n, $largest);
    }
}

function heapSort(array &$arr) {
    $n = count($arr);
    
    for ($i = intdiv($n, 2) - 1; $i >= 0; $i--) {
        heapify($arr, $n, $i);
    }
    
    for ($i = $n - 1; $i > 0; $i--) {
        $temp = $arr[0];
        $arr[0] = $arr[$i];
        $arr[$i] = $temp;
        heapify($arr, $i, 0);
    }
}

$arr = [12, 11, 13, 5, 6, 7];
heapSort($arr);
print_r($arr);
//Array
//(
//    [0] => 5
//    [1] => 6
//    [2] => 7
//    [3] => 11
//    [4] => 12
//    [5] => 13
//)
```

# Domain Driven Design
> ### Подход к разработке, который фокусируется на глубоком понимании предметной области для создания лёгкой в понимании, легко масштабируемой и гибкой системы

# Service Provider
> ### Центральный механизм внедрения зависимостей и регистрации сервисов приложения
> ### Провайдеры регистрируют сервисы и классы в сервис-контейнере. Внутренние сервисы / библиотеки / сторонние пакеты
```php
public function register()
{
   // Регистрируем API сервис в контейнере
   $this->app->singleton(SomeApiService::class, function ($app) {
   	return new SomeApiService(config('services.someapi'));
   });
}
```

# Closure
> ### Анонимная функция, которая может быть сохранена в переменной || передана как аргумент другой функции || возвращена как значение из другой функции
```php
$greet = function($name) {
    return "Привет, $name!";
};

echo $greet("Иван");
```
```php
function processGreeting($name, $callback) {
    return $callback($name);
}

$greet = function($name) {
    return "Привет, $name!";
};

echo processGreeting("Анна", $greet);
```
```php
function getGreetingFunction() {
    return function($name) {
        return "Привет, $name!";
    };
}

$greet = getGreetingFunction();
echo $greet("Мария");
```

# Стрелочная функция
> ### Сокращённый вариант анонимной функции без use & return

# PHP FPM
> ### Способ работы с php, который делает его более быстрым и эффективным при обработке большого числа запросов
> ### Вместо запуска php для каждого запроса создаётся несколько рабочих процессов, которые готовы обработать запросы
> ### Когда приходит запрос он сразу перенаправляется на свободный процесс, что ускоряет обработку
> ### Автоматически увеличивает/уменьшает количество воркеров, в зависимости от трафика

# Nginx
> ### Веб-сервер, работающий на unix-подобных ос
> ### Используется для обработки http запросов || как обратный прокси (посредник) || как балансировщик нагрузки 

# Рефлексия
> ### Создание экземпляра класса и вызова метода динамически

# Explain analyze
> ### Инструмент анализа производительности запросов mysql
> ### Предоставляет данные о времени выполнения, помогает глубже понять узкие места и оптимизировать запросы

# Паттерны проектирования
## Repository
> ### Изолирует логику доступа к данным от остальной логики приложения
> ### Это делает код более чистым и гибким при работе с различными исочниками (БД || API)
> ## Когда использовать
> ### Когда нужно отделить бизнес-логику от доступа к данным
> ### Когда нужно легко изменять источник данных (к примеру mysql на mongoDb)
> ## Когда не использовать
> ### В маленьких приложениях где изолирование доступа к данным добавляет ненужную сложность
```php
class OrderRepository
{
    public function find($id)
    {
        return Order::find($id);
    }

    public function create(array $data)
    {
        return Order::create($data);
    }
}

class OrderService
{
    protected $orderRepo;

    public function __construct(OrderRepository $orderRepo)
    {
        $this->orderRepo = $orderRepo;
    }

    public function placeOrder($orderData)
    {
        return $this->orderRepo->create($orderData);
    }
}
```
## Service
> ### Позволяет вынести бизнес-логику из контроллеров или других частей приложения в отдельные классы (сервисы)
> ### Это делает код более чистым и позволяет легко тестировать бизнес логику
> ## Когда использовать
> ### Когда нужно организовать повторно используемую бизнес-логику
> ### Когда логика становится слишком сложной для контроллера
> ## Когда не использовать
> ### В простых приложениях, где логика в контроллере достаточно компактна
```php
class OrderService
{
    public function createOrder($data): Order
    {
        return Order::create($data);
    }
}

class OrderController extends Controller
{
    protected $orderService;

    public function __construct(OrderService $orderService)
    {
        $this->orderService = $orderService;
    }

    public function store(Request $request)
    {
        $this->orderService->createOrder($request->all());
    }
}
```
## Strategy
> ### Позволяет выбирать алгоритм выполнения задачи во время выполнения программы
> ### Может быть полезно когда нужно динамически выбрать логику выполнения определенной операции (к примеру разные методы оплаты)
> ## Когда использовать
> ### Когда нужно реализовать разные стратегии для выполнения одной и той же задачи (например, расчет цены в зависимости от региона)
> ### Когда алгоритмы часто меняются
> ## Когда не использовать
> ### Когда алгоритм выбора не изменяется и может быть жестко закодирован
```php
interface PaymentStrategy
{
    public function pay($amount);
}

class PayPalPayment implements PaymentStrategy
{
    public function pay($amount)
    {
        return "Paid $amount using PayPal";
    }
}

class CreditCardPayment implements PaymentStrategy
{
    public function pay($amount)
    {
        return "Paid $amount using Credit Card";
    }
}

class PaymentService
{
    protected $paymentStrategy;

    public function __construct(PaymentStrategy $paymentStrategy)
    {
        $this->paymentStrategy = $paymentStrategy;
    }

    public function processPayment($amount)
    {
        return $this->paymentStrategy->pay($amount);
    }
}

$paymentService = (new PaymentService(new PayPalPayment()))->processPayment(1_000);
```
## Decorator
> ### Позволяет добавлять функциональность объекту динамически, не изменяя его структуру
> ### В Laravel его часто используют для динамического добавления поведения к объектам (например, валидация или форматирование)
> ## Когда использовать
> ### Когда нужно добавить поведение объекту без изменения его исходного кода
> ### Когда требуется гибкость для добавления новой функциональности к существующим объектам
> ## Когда не использовать
> ### Если можно использовать простое наследование или композицию для добавления поведения
```php
interface Notifier
{
    public function send(string $message);
}

class BasicNotifier implements Notifier
{
    public function send(string $message)
    {
        return "Sending notification: $message";
    }
}

class NotifierDecorator implements Notifier
{
    protected $notifier;

    public function __construct(Notifier $notifier)
    {
        $this->notifier = $notifier;
    }

    public function send(string $message)
    {
        return $this->notifier->send($message);
    }
}

class EmailNotifier extends NotifierDecorator
{
    public function send(string $message)
    {
        return parent::send("Email: $message");
    }
}

class SMSNotifier extends NotifierDecorator
{
    public function send(string $message)
    {
        return parent::send("SMS: $message");
    }
}

$notifier = new EmailNotifier(new BasicNotifier());
echo $notifier->send("Order processed"); 

$notifier = new SMSNotifier(new EmailNotifier(new BasicNotifier()));
echo $notifier->send("Order processed");
```
## Singleton
> ### Порождающий паттерн, гарантирующий что у класса будет только 1 экземпляр и предоставляющий глобальную точку доступа к экземпляру
> ### Laravel уже использует этот паттерн для многих служб (бд & кэши)
> ## Когда использовать
> ### Когда нужно, чтобы был только один экземпляр объекта (например, при работе с ресурсами системы: базы данных, логирование)
> ## Когда не использовать
> ### Когда объект не требует такого ограничения или Singleton нарушает тестируемость
```php
class SingletonClass
{
    private static $instance = null;

    private function __construct() {}

    public static function getInstance()
    {
        if (self::$instance == null) {
            self::$instance = new SingletonClass();
        }

        return self::$instance;
    }
}
```
## Adapter
> ### Структурный паттерн, который позволяет объектам с несовместимыми интерфейсами работать вместе
> ### Служит для преобразования одного интерфейса в другой, нужный клиенту
> ## Когда использовать
> ### Когда требуется использовать сторонний класс с несовместимым интерфейсом
> ### Когда вы работаете с API, которые вам необходимо интегрировать в проект, не изменяя их исходный код
> ### Когда хотите использовать старый код с новым интерфейсом
> ## Когда не использовать
> ### Если можно напрямую изменить или расширить сторонний класс
> ### Если интерфейсы объектов уже совместимы, и адаптер только усложнит структуру
```php
interface NewPaymentGateway
{
    public function sendPayment(float $amount);
}

class OldPaymentSystem
{
    public function processPayment(float $amount)
    {
        return "Processing payment of $amount via old system.";
    }
}

class PaymentAdapter implements NewPaymentGateway
{
    private $oldPaymentSystem;

    public function __construct(OldPaymentSystem $oldPaymentSystem)
    {
        $this->oldPaymentSystem = $oldPaymentSystem;
    }

    public function sendPayment(float $amount)
    {
        return $this->oldPaymentSystem->processPayment($amount);
    }
}

$oldSystem = new OldPaymentSystem();
$adapter = (new PaymentAdapter($oldSystem))->sendPayment(1_000);
```
## Factory Method
> ### Порождающий паттерн, который предоставляет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта
> ### Позволяет создавать объекты, не указывая точный класс, который будет создан
> ## Когда использовать
> ### Когда нужно делегировать логику создания объектов подклассам
> ### Когда процесс создания объектов сложен, и создание каждого объекта требует своих параметров или конфигураций
> ### Когда нужно гарантировать, что создаются только определенные типы объектов
> ## Когда не использовать
> ### Когда создание объектов достаточно простое и не требует гибкости
> ### Когда не требуется управление процессом создания объектов
```php
interface Logger
{
    public function log(string $message);
}

class FileLogger implements Logger
{
    public function log(string $message)
    {
        return "Log to file: $message";
    }
}

class DatabaseLogger implements Logger
{
    public function log(string $message)
    {
        return "Log to database: $message";
    }
}

abstract class LoggerFactory
{
    abstract public function createLogger(): Logger;

    public function logMessage(string $message)
    {
        $logger = $this->createLogger();
        return $logger->log($message);
    }
}

class FileLoggerFactory extends LoggerFactory
{
    public function createLogger(): Logger
    {
        return new FileLogger();
    }
}

class DatabaseLoggerFactory extends LoggerFactory
{
    public function createLogger(): Logger
    {
        return new DatabaseLogger();
    }
}

$fileLoggerFactory = (new FileLoggerFactory())->logMessage("File logging message");
$dbLoggerFactory = (new DatabaseLoggerFactory())->logMessage("Database logging message");
```
## Abstract Factory
> ### Порождающий паттерн, который предоставляет интерфейс для создания семейства взаимосвязанных или взаимозависимых объектов без указания их конкретных классов
> ### В отличии от Factory Method, Abstract Factory создаёт не один объект, а несколько связанных
> ## Когда использовать
> ### Когда нужно создавать семейства связанных объектов
> ### Когда необходимо гарантировать совместимость создаваемых продуктов (например, элементы пользовательского интерфейса, которые должны сочетаться друг с другом)
> ### Когда нужна высокая степень абстракции над процессом создания объектов
> ## Когда не использовать
> ### Когда система проста, и нет необходимости создавать семейства объектов
> ### Если каждый продукт может создаваться независимо от других продуктов
```php
interface Button
{
    public function render();
}

interface Checkbox
{
    public function render();
}

class WindowsButton implements Button
{
    public function render()
    {
        return "Rendering Windows button";
    }
}

class WindowsCheckbox implements Checkbox
{
    public function render()
    {
        return "Rendering Windows checkbox";
    }
}

class MacButton implements Button
{
    public function render()
    {
        return "Rendering Mac button";
    }
}

class MacCheckbox implements Checkbox
{
    public function render()
    {
        return "Rendering Mac checkbox";
    }
}

interface UIFactory
{
    public function createButton(): Button;
    public function createCheckbox(): Checkbox;
}

class WindowsFactory implements UIFactory
{
    public function createButton(): Button
    {
        return new WindowsButton();
    }

    public function createCheckbox(): Checkbox
    {
        return new WindowsCheckbox();
    }
}

class MacFactory implements UIFactory
{
    public function createButton(): Button
    {
        return new MacButton();
    }

    public function createCheckbox(): Checkbox
    {
        return new MacCheckbox();
    }
}

// Использование:
function renderUI(UIFactory $factory)
{
    $button = $factory->createButton();
    $checkbox = $factory->createCheckbox();
    echo $button->render() . PHP_EOL;
    echo $checkbox->render() . PHP_EOL;
}

// Создание интерфейса для Windows
renderUI(new WindowsFactory()); 
// "Rendering Windows button"
// "Rendering Windows checkbox"

// Создание интерфейса для Mac
renderUI(new MacFactory());
// "Rendering Mac button"
// "Rendering Mac checkbox"
```
## Builder
> ### Порождающий паттерн, который используется для пошагового создания сложных объектов
> ### В отличии от других порождающий паттернов, таких как фабричный метод или абстрактная фабрика - строитель позволяет конструировать объект поэтапно и предлагает больше гибкости в процессе сборки
> ## Когда использовать
> ### Когда нужно создавать сложные объекты с множеством параметров или конфигураций
> ### Когда процесс создания объекта должен быть независим от его внутренней структуры
> ### Когда необходимо собирать объекты разными способами, но при этом общий процесс должен оставаться одинаковым
> ## Когда не использовать
> ### Если объект достаточно прост и не требует множества шагов для создания
> ### Если нет необходимости в различных вариантах создания одного и того же объекта
```php
class Car
{
    public $engine;
    public $wheels;
    public $seats;

    public function __construct($engine, $wheels, $seats)
    {
        $this->engine = $engine;
        $this->wheels = $wheels;
        $this->seats = $seats;
    }

    public function getDescription()
    {
        return "Car with {$this->engine} engine, {$this->wheels} wheels, and {$this->seats} seats.";
    }
}

class CarBuilder
{
    private $engine;
    private $wheels;
    private $seats;

    public function setEngine($engine)
    {
        $this->engine = $engine;
        return $this;
    }

    public function setWheels($wheels)
    {
        $this->wheels = $wheels;
        return $this;
    }

    public function setSeats($seats)
    {
        $this->seats = $seats;
        return $this;
    }

    public function build()
    {
        return new Car($this->engine, $this->wheels, $this->seats);
    }
}

$carBuilder = new CarBuilder();
$car = $carBuilder->setEngine('V8')->setWheels(4)->setSeats(5)->build();
```
# HTTP Codes
> ## 1xx информационные
> ## 2xx успешные
> ## 3xx перенаправления
> ## 4xx ошибки клиента
> ## 5xx ошибки сервера